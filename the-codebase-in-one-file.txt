
//filepath: src\app.jsx
import { useState } from "react";
import { NavigationBar } from "./comp/nabigation-bar";
import { ChatRoom } from "./comp/chat-room";
import { JoinChat } from "./comp/join-chat";
import { useWsClient } from "./hooks/use-ws-client";
import Mobile from "./mobile";

// Main Application Component
export default function App({ setData, data }) {
  let currentChat, setCurrentChat;

  const { client, state, reCreateClient, isClosed } = useWsClient(
    data,
    setData,
    currentChat,
    setCurrentChat
  );

  [currentChat, setCurrentChat] = useState(
    Object.keys(data || {})?.[0] ?? null
  );

  if (state === "failed" || isClosed) {
    return <button onClick={() => reCreateClient()}>Reconnect</button>;
  }

  if (client == null) return state;

  if (innerWidth > 768)
    return (
      <div className="app-container">
        <NavigationBar
          chats={data}
          currentChat={currentChat}
          setCurrentChat={setCurrentChat}
          setChats={setData}
          client={client}
        />
        <aside>
          <JoinChat
            setCurrentChat={setCurrentChat}
            client={client}
            setData={setData}
          />
        </aside>
        <main>
          {currentChat && data[currentChat] ? (
            <ChatRoom
              chatId={currentChat}
              chatData={data[currentChat]}
              client={client}
              setData={setData}
            />
          ) : (
            <div className="no-chat-selected">
              <p>
                Please select a chat from the navigation bar or join a new chat.
              </p>
            </div>
          )}
        </main>
      </div>
    );
  else
    return (
      <Mobile
        client={client}
        currentChat={currentChat}
        data={data}
        setCurrentChat={setCurrentChat}
        setData={setData}
      />
    );
}


//filepath: src\comp\chat-room-header.jsx
import QRCode from "react-qr-code";

export function ChatRoomHeader({ chatId, chatData, setData }) {
  return (
    <header>
      <h3>{chatId}</h3>
      <button
        type="button"
        onClick={(_) =>
          document.getElementById("chat-data-form").classList.toggle("none")
        }
      >
        Edit
      </button>
      <form
        className="none"
        id="chat-data-form"
        onSubmit={(e) => {
          e.preventDefault();
          const fd = new FormData(e.target);
          if (
            !confirm(
              "Are you sure you want to change your public chat password or username?"
            )
          )
            return;
          setData((old) => {
            return {
              ...old,
              [chatId]: {
                ...old[chatId],
                password: fd.get("password"),
                author: fd.get("author"),
              },
            };
          });
          e.target.classList.add("none");
        }}
      >
        <button
          type="reset"
          onClick={(e) => {
            e.preventDefault();
            e.target.parentElement.classList.add("none");
          }}
        >
          Close
        </button>
        <input
          name="author"
          type="text"
          placeholder="name..."
          defaultValue={chatData.author}
        />
        <input
          name="password"
          type="password"
          defaultValue={chatData.password}
        />
        <button type="submit">change data</button>
      </form>
      <QRCode
        className="qr-code"
        value={`${chatId}\n${chatData.password}`}
        size={60}
        tabIndex={-1}
      />
    </header>
  );
}


//filepath: src\comp\chat-room-send-form.jsx
import { encrypt, randomBytes } from "../utils/crypto";

export default function ChatRoomSendForm({
  chatId,
  chatData,
  client,
  setData,
}) {
  const handleSubmit = async (e) => {
    e.preventDefault();
    const fd = new FormData(e.target);
    const message = {
      type: fd.get("type"),
      data: fd.get("text"),
      date: new Date().toLocaleDateString(),
      author: chatData.author,
    };

    const messagePublic = {
      id: randomBytes(4).toString(),
    };

    // Update local state with the new message
    setData((old) => ({
      ...old,
      [chatId]: {
        ...old[chatId],
        messages: [...old[chatId].messages, { ...message, ...messagePublic }],
      },
    }));

    const isSent = await client.get("send", {
      chatId,
      message: encrypt(chatData.password, JSON.stringify(message)),
      ...messagePublic,
    });
    if (!isSent) {
      alert("A send error occurred");
    }
    e.target.reset();

    const messagesDiv = document.querySelector(".messages");
    if (messagesDiv) {
      messagesDiv.lastChild?.scrollIntoView?.({
        behavior: "smooth",
        block: "center",
      });
    }
  };

  return (
    <form onSubmit={handleSubmit} className="message-form">
      {/* <select name="type">
             <option value="text">Text</option>
         </select> */}
      <input type="hidden" value="text" name="type" />
      <input
        autoFocus
        type="text"
        name="text"
        placeholder="Type your message..."
        required
        autoComplete="off"
        autoCorrect="off"
        spellCheck="false"
      />
      <button type="submit">Send</button>
    </form>
  );
}


//filepath: src\comp\chat-room.jsx
import Message from "./message";
import { ChatRoomHeader } from "./chat-room-header";
import ChatRoomSendForm from "./chat-room-send-form";
import { useEffect } from "react";

// Component for displaying and sending messages in a chat room
export function ChatRoom({ chatId, chatData, client, setData, page }) {
  useEffect(() => {
    if (page === true) {
      return;
    }
    const messages = document.querySelectorAll(".message");
    if (messages && messages[messages.length - 1]) {
      messages[messages.length - 1].scrollIntoView({
        behavior: "instant",
        block: "center",
      });
    }
  }, [chatId, page]);

  return (
    <div className="chat-room">
      <ChatRoomHeader chatData={chatData} chatId={chatId} setData={setData} />
      <div className="messages">
        {chatData.messages.map((msg, index) => (
          <Message
            msg={msg}
            chatData={chatData}
            index={index}
            key={msg.id || index}
            chatId={chatId}
            client={client}
            setData={setData}
          />
        ))}
      </div>
      <ChatRoomSendForm
        chatData={chatData}
        chatId={chatId}
        setData={setData}
        client={client}
      />
    </div>
  );
}


//filepath: src\comp\join-chat.jsx
import { useState } from "react";
import Html5QrcodePlugin from "./qr-code-scanner";
import { basicHash, decrypt } from "../utils/crypto";

// Component for joining a new chat room
export function JoinChat({ client, setData, setCurrentChat, setPage }) {
  const [scanQrCode, setScanQrCode] = useState(false);
  const [[chatId, password], setChatData] = useState(["", ""]);

  const handleJoin = async (e) => {
    e.preventDefault();

    const fd = new FormData(e.target);
    const chatId = fd.get("id");
    const password = fd.get("password");
    const author = fd.get("author");

    if (!chatId || !password)
      return alert(
        "Please Scan QR Code first or switch to input mode and input the group id and password."
      );

    const data = await client.get("join", {
      chatId,
      passwordHash: basicHash(basicHash(password)),
      author,
      messageIds: {},
    });

    if (data === false) {
      alert(
        `You are in the chat: ${fd.get("id")} or your password is incorrect`
      );
      return;
    }

    setData((old) => ({
      ...old,
      [chatId]: {
        password,
        messages: data.map(({ id, message }) => {
          try {
            return { ...JSON.parse(decrypt(password, message)), id };
          } catch (error) {
            return {
              type: "error",
              data: "an error occurred (wrong password) (ignorable error)",
            };
          }
        }),
        author,
        unread: 0,
      },
    }));

    setCurrentChat(chatId);
    e.target.reset();
    setScanQrCode(false);
    setChatData(["", ""]);

    if (setPage) setPage(false);
  };

  return !scanQrCode ? (
    <form onSubmit={handleJoin} className="join-form">
      <input
        autoComplete="off"
        autoCorrect="off"
        spellCheck="false"
        type="text"
        name="id"
        placeholder="Group to join..."
        required
      />
      <input
        autoComplete="off"
        autoCorrect="off"
        spellCheck="false"
        type="password"
        name="password"
        placeholder="Encryption password..."
        required
      />
      <input type="text" name="author" placeholder="Your name..." required />

      <button type="submit">Join Chat</button>
      <button
        type="submit"
        onClick={(e) => {
          e.preventDefault();
          setScanQrCode(true);
        }}
      >
        Scan QR Code
      </button>
    </form>
  ) : (
    <form onSubmit={handleJoin} className="join-form qr-code-form">
      <button
        type="submit"
        onClick={(e) => {
          e.preventDefault();
          setScanQrCode(false);
        }}
      >
        Input Your Data Manual
      </button>
      <Html5QrcodePlugin
        fps={10}
        qrbox={350}
        disableFlip={false}
        qrCodeSuccessCallback={(decodedText = "") => {
          const [chatId, password] = decodedText.split("\n") || ["", ""];
          if (!chatId || !password) {
            return alert("error: Invalid QR Code");
          }
          setChatData([chatId, password]);
          document.getElementById("author-input").focus();
        }}
      />
      {chatId && password && (
        <>
          <input
            type="text"
            name="id"
            placeholder="Group to join..."
            value={chatId}
            readOnly
            required
          />
          <input
            type="text"
            name="password"
            placeholder="Group Password..."
            value={password}
            readOnly
            required
          />
        </>
      )}
      <input
        type="text"
        name="author"
        id="author-input"
        placeholder="Your name..."
        required
      />
      <button type="submit">Join Chat</button>
    </form>
  );
}


//filepath: src\comp\message.jsx
const userColors = {};

export default function Message({
  chatData,
  msg,
  index,
  client,
  chatId,
  setData,
}) {
  // Generate a random color for the user if they don't have one already.
  if (!userColors[msg.author]) {
    userColors[msg.author] = `rgb(${Math.floor(
      Math.random() * 100 + 50
    )}, ${Math.floor(Math.random() * 100 + 50)}, ${Math.floor(
      Math.random() * 100 + 50
    )})`;
  }

  return (
    <div
      key={index}
      style={{ backgroundColor: userColors[msg.author] }}
      className={
        "message" + (msg.author == chatData.author ? " own-msg" : " other")
      }
      onContextMenu={async (e) => {
        e.preventDefault();
        if (!confirm("Are you sure you want to delete this message")) return;
        const isSent = await client.get("delete-message", {
          id: msg.id,
          chatId,
        });
        if (!isSent) alert("error: message isn't deleted");
        setData((old) => {
          let messages = old[chatId].messages.filter((m) => m.id !== msg.id);
          return {
            ...old,
            [chatId]: {
              ...old[chatId],
              messages,
            },
          };
        });
      }}
    >
      <p>{msg.data}</p>
      <p className="meta">
        {msg.date} | {msg.author}
      </p>
    </div>
  );
}


//filepath: src\comp\nabigation-bar.jsx
// Navigation bar to switch between chat groups
export function NavigationBar({
  chats,
  currentChat,
  setCurrentChat,
  setChats,
  client,
  setPage,
}) {
  return (
    <nav className="nav-bar">
      <ul>
        {Object.keys(chats).map((chatId) => (
          <li
            key={chatId}
            className={chatId === currentChat ? "active" : ""}
            onContextMenu={(e) => {
              e.preventDefault();
              if (
                !confirm(
                  `Are you sure you want to delte the chat "${chatId}" with all messages?`
                )
              )
                return;
              setChats((old) => {
                const newChats = { ...old };
                delete newChats[chatId];
                return newChats;
              });

              client.get("exit", chatId);
            }}
          >
            <button
              onClick={() => {
                setCurrentChat(chatId);
                if (setPage) setPage(false);
                setChats((old) => {
                  return {
                    ...old,
                    [chatId]: {
                      ...old[chatId],
                      unread: 0,
                    },
                  };
                });
                const messageInput = document.querySelector(
                  '.chat-room .message-form input[name="text"]'
                );
                messageInput.focus();

                const chatElem = document.querySelector(".chat-room");
                chatElem.scrollIntoView({
                  block: "start",
                  behavior: "smooth",
                });
              }}
            >
              <span>{chatId}</span>
              <span
                className={
                  "unread" + (chats[chatId].unread == 0 ? " hide" : "")
                }
              >
                {chats[chatId].unread}
              </span>
            </button>
          </li>
        ))}
      </ul>
    </nav>
  );
}


//filepath: src\comp\qr-code-scanner.jsx
import { Html5QrcodeScanner } from "html5-qrcode";
import { useEffect } from "react";

const qrcodeRegionId = "html5qr-code-full-region";

// Creates the configuration object for Html5QrcodeScanner.
function createConfig(props) {
  /**
   * @type {import("html5-qrcode/esm/html5-qrcode-scanner").Html5QrcodeScannerConfig}
   */
  let config = {};
  if (props.fps) {
    config.fps = props.fps;
  }
  if (props.qrbox) {
    config.qrbox = props.qrbox;
  }
  if (props.aspectRatio) {
    config.aspectRatio = props.aspectRatio;
  }
  if (props.disableFlip !== undefined) {
    config.disableFlip = props.disableFlip;
  }
  return config;
}

export default function Html5QrcodePlugin(props) {
  useEffect(() => {
    // when component mounts
    const config = createConfig(props);
    const verbose = props.verbose === true;
    // Suceess callback is required.
    if (!props.qrCodeSuccessCallback) {
      throw "qrCodeSuccessCallback is required callback.";
    }
    const html5QrcodeScanner = new Html5QrcodeScanner(
      qrcodeRegionId,
      config,
      verbose
    );
    html5QrcodeScanner.render(
      props.qrCodeSuccessCallback,
      props.qrCodeErrorCallback
    );

    // cleanup function when component will unmount
    return () => {
      html5QrcodeScanner.clear().catch((error) => {
        console.error("Failed to clear html5QrcodeScanner. ", error);
      });
    };
  }, []);

  return <div id={qrcodeRegionId} />;
}


//filepath: src\config.jsx
export const serverURL =
  document.location.protocol == "http:"
    ? "ws://localhost:8080"
    : "wss://easy-messenger.onrender.com";


//filepath: src\hooks\use-ws-client.jsx
import createClient from "../utils/create-client";
import { useClient } from "wsnet-client-react";
import { useEffect } from "react";
import initClient from "../utils/init-client";

// Custom hook to handle the WebSocket client connection and incoming messages
export function useWsClient(data, setData, selectedChat, setCurrentChat) {
  const [client, state, reCreateClient, isClosed] = useClient(
    createClient(setData, selectedChat, setCurrentChat),
    true,
    true
  );

  useEffect(() => {
    if (!client) return;
    initClient(client, data, setData);
  }, [client]);

  return {
    data,
    setData,
    client,
    state,
    reCreateClient,
    isClosed,
  };
}


//filepath: src\main.jsx
import { createRoot } from "react-dom/client";
import App from "./app.jsx";
import { useEffect, useState } from "react";
import useLocalStorage from "use-local-storage";
import { decrypt, encrypt } from "./utils/crypto.jsx";
import "./styles/import.jsx";
import "./pwa.jsx";

function Main() {
  useEffect(() => {
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker
        .register("/easy-messenger/service-worker.js")
        .then(() => {
          console.log("Service Worker Active!");
        });
    }
  }, []);

  const [password, setPassword] = useState(null);
  const [data, setData] = useLocalStorage("enc-chat-data", null);
  const [isAuth, setIsAuth] = useState(false);

  // Handler for creating an account
  const handleCreateAccount = (e) => {
    e.preventDefault();
    const inputPassword = e.target.password.value;
    if (!inputPassword) return; // Optionally display an error
    if (inputPassword != prompt("reinput the password")) {
      e.target.reset();
      return alert("wrong password");
    }
    setPassword(inputPassword);
    // Encrypt an empty JSON string to start with
    const encryptedData = encrypt(inputPassword, "{}");
    setData(encryptedData);
    setIsAuth(true);
  };

  // Handler for logging in
  const handleLogin = (e) => {
    e.preventDefault();
    const inputPassword = e.target.password.value;
    if (!inputPassword) return alert("Incorrect password");
    try {
      // Attempt to decrypt stored data using the provided password.
      const decryptedData = decrypt(inputPassword, data);
      // Validate that the decrypted data is valid JSON.
      JSON.parse(decryptedData);
    } catch (error) {
      alert("Incorrect password");
      return;
    }
    setPassword(inputPassword);
    setIsAuth(true);
  };

  // A wrapper to update the data and automatically encrypt the new value.
  const updateData = (newData) => {
    if (typeof newData === "function") {
      setData((prevData) =>
        encrypt(
          password,
          JSON.stringify(newData(JSON.parse(decrypt(password, prevData))))
        )
      );
    } else {
      setData(encrypt(password, JSON.stringify(newData)));
    }
  };

  // Define a reusable login form.
  const loginHtml = (
    <fieldset className="login">
      <legend>
        <h1>Login</h1>
      </legend>
      <form onSubmit={handleLogin} className="form">
        <p>
          Password:
          <input
            type="password"
            autoComplete="off"
            autoCorrect="off"
            spellCheck="false"
            autoFocus
            placeholder="Enter password..."
            name="password"
            className="input"
          />
        </p>
        <p id="error" className="error"></p>
        <button type="submit" className="button">
          Login
        </button>
      </form>
    </fieldset>
  );

  // Define a reusable create account form.
  const createAccountHtml = (
    <fieldset className="login">
      <legend>
        <h1>Create Account</h1>
      </legend>
      <form onSubmit={handleCreateAccount} className="form">
        <p>
          Password:
          <input
            type="password"
            autoComplete="off"
            autoCorrect="off"
            spellCheck="false"
            placeholder="Enter password..."
            name="password"
            autoFocus
            className="input"
          />
        </p>
        <p id="error" className="error"></p>
        <button type="submit" className="button">
          Create Account
        </button>
      </form>
    </fieldset>
  );

  // If no account exists, show the create account form.
  if (data === null) {
    return createAccountHtml;
  }

  // If the user exists but is not authenticated, show the login form.
  if (!isAuth) {
    return loginHtml;
  }

  const dataString = decrypt(password, data);
  // If authenticated, render the main app.
  return <App data={JSON.parse(dataString)} setData={updateData} />;
}

createRoot(document.getElementById("root")).render(<Main />);


//filepath: src\mobile.jsx
import { useState } from "react";
import { ChatRoom } from "./comp/chat-room";
import { JoinChat } from "./comp/join-chat";
import { NavigationBar } from "./comp/nabigation-bar";

export default function Mobile({
  currentChat,
  setCurrentChat,
  client,
  setData,
  data,
}) {
  const [page, setPage] = useState(true);

  return (
    <div className="app-container mobile">
      <div className="page" style={{ display: page ? "" : "none" }}>
        <NavigationBar
          chats={data}
          currentChat={currentChat}
          setCurrentChat={setCurrentChat}
          setChats={setData}
          client={client}
          setPage={setPage}
        />
        <aside>
          <JoinChat
            setCurrentChat={setCurrentChat}
            client={client}
            setData={setData}
            setPage={setPage}
          />
        </aside>
      </div>
      <div className="page" style={{ display: !page ? "" : "none" }}>
        <main>
          {currentChat && data[currentChat] ? (
            <ChatRoom
              chatId={currentChat}
              chatData={data[currentChat]}
              client={client}
              setData={setData}
              page={page}
            />
          ) : (
            <div className="no-chat-selected">
              <p>
                Please select a chat from the navigation bar or join a new chat.
              </p>
            </div>
          )}
        </main>
      </div>
      <div className="navigation">
        <button className={page ? "active" : ""} onClick={() => setPage(true)}>
          Chats
        </button>
        <button
          className={!page ? "active" : ""}
          onClick={() => setPage(false)}
        >
          Chat
        </button>
      </div>
    </div>
  );
}


//filepath: src\pwa.jsx
let deferredPrompt;
const installBtn = document.getElementById("installBtn");

window.addEventListener("beforeinstallprompt", (e) => {
  e.preventDefault();
  deferredPrompt = e;
  installBtn.style.display = "block";
});

installBtn.addEventListener("click", () => {
  deferredPrompt.prompt();
  deferredPrompt.userChoice.then((choiceResult) => {
    if (choiceResult.outcome === "accepted") {
      console.log("User accepted the install prompt");
    } else {
      console.log("User dismissed the install prompt");
    }
    deferredPrompt = null;
    installBtn.style.display = "none";
  });
});


//filepath: src\styles\import.jsx
//impor all files

import "./globals.css";
import "./login.css";
import "./layout.css";
import "./navbar.css";
import "./chat.css";
import "./messages.css";
import "./message-form.css";
import "./join-form.css";
import "./install-button.css";


//filepath: src\utils\create-client.jsx
import { serverURL } from "../config";
import { decrypt, randomBytes } from "../utils/crypto";

import CryptoJS from "crypto-js";
import Client from "wsnet-client";

export default function createClient(setData, selectedChat, setSelectedChat) {
  return () => {
    const client = new Client(serverURL);

    client.onSay("message", ({ chatId, message, messageId }) => {
      setData((old) => {
        let messageData;
        try {
          messageData = {
            ...JSON.parse(decrypt(old[chatId].password, message)),
            id: messageId,
          };

          const messagesDiv = document.querySelector(".messages");
          if (messagesDiv) {
            if (
              messagesDiv.scrollTop == 0 ||
              messagesDiv.scrollHeight - messagesDiv.scrollTop < innerHeight
            ) {
              messagesDiv.lastChild?.scrollIntoView?.({
                behavior: "smooth",
                block: "center",
              });
            }
          }
        } catch (error) {
          messageData = { type: "error", data: "wrong key\n" + error };
        }

        return {
          ...old,
          [chatId]: {
            ...old[chatId],
            messages: [...old[chatId].messages, messageData],
            unread: chatId == selectedChat ? 0 : old[chatId].unread + 1,
          },
        };
      });
    });

    client.onSay("message-deleted", ({ chatId, messageId }) => {
      setData((old) => {
        let messages = old[chatId].messages.filter(
          (message) => message.id !== messageId
        );
        return {
          ...old,
          [chatId]: {
            ...old[chatId],
            messages,
          },
        };
      });
    });

    client.onSay("chat-deleted", ({ chatId }) => {
      setData((old) => {
        const newData = { ...old };
        delete newData[chatId];
        return newData;
      });
      setSelectedChat(null);
    });

    client.onSay("user-joined", ({ chatId, message }) => {
      setData((old) => {
        return {
          ...old,
          [chatId]: {
            ...old[chatId],
            messages: [
              ...old[chatId].messages,
              {
                type: "user-joined",
                data: message,
                author: message,
                id: randomBytes(4).toString(CryptoJS.enc.Hex),
              },
            ],
          },
        };
      });
    });

    client.onSay("user-exited", ({ chatId, message }) => {
      setData((old) => {
        return {
          ...old,
          [chatId]: {
            ...old[chatId],
            messages: [
              ...old[chatId].messages,
              {
                type: "user-exited",
                data: message,
                author: message,
                id: randomBytes(4).toString(CryptoJS.enc.Hex),
              },
            ],
          },
        };
      });
    });

    return client;
  };
}


//filepath: src\utils\crypto.jsx
import CryptoJS from "crypto-js";

// Generate random bytes
export function randomBytes(length) {
  return CryptoJS.lib.WordArray.random(length);
}

// Derive a key using PBKDF2
function deriveKey(password, salt, iterations = 100, keySize = 256) {
  return CryptoJS.PBKDF2(password, salt, {
    keySize: keySize / 32,
    iterations: iterations,
    hasher: CryptoJS.algo.SHA512,
  });
}

// Encrypt data using AES-CBC with PKCS7 padding
export function encrypt(password = "", data = "") {
  const salt = randomBytes(32);
  const iv = randomBytes(16);
  const key = deriveKey(password, salt);
  const encrypted = CryptoJS.AES.encrypt(data, key, {
    iv: iv,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7,
  });
  // Concatenate salt, iv, and ciphertext
  return salt
    .concat(iv)
    .concat(encrypted.ciphertext)
    .toString(CryptoJS.enc.Base64);
}

// Decrypt data using AES-CBC with PKCS7 padding
export function decrypt(password = "", data = "") {
  const rawData = CryptoJS.enc.Base64.parse(data);
  const salt = CryptoJS.lib.WordArray.create(rawData.words.slice(0, 8));
  const iv = CryptoJS.lib.WordArray.create(rawData.words.slice(8, 12));
  const ciphertext = CryptoJS.lib.WordArray.create(rawData.words.slice(12));
  const key = deriveKey(password, salt);
  const decrypted = CryptoJS.AES.decrypt({ ciphertext: ciphertext }, key, {
    iv: iv,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7,
  });
  return decrypted.toString(CryptoJS.enc.Utf8);
}

// SHA-512 Hash with salt and iterations
export function hash(data, salt = "10", times = 1) {
  let hash = CryptoJS.SHA512(data + salt);
  for (let i = 1; i < times; i++) {
    hash = CryptoJS.SHA512(hash + salt);
  }
  return hash.toString(CryptoJS.enc.Hex);
}

export function basicHash(data) {
  return CryptoJS.SHA512(data).toString(CryptoJS.enc.Hex);
}


//filepath: src\utils\init-client.jsx
import Client from "wsnet-client";
import { basicHash, decrypt, randomBytes } from "./crypto";

import CryptoJS from "crypto-js";

/**
 * @param {Client} client
 */
export default async function initClient(client, data, setData) {
  // Clean up messages: remove "joined" and "exited" types from every chat.
  setData((oldData) =>
    Object.keys(oldData).reduce((acc, chatId) => {
      acc[chatId] = {
        ...oldData[chatId],
        messages: oldData[chatId].messages.filter(
          ({ type }) => type !== "user-joined" && type !== "user-exited"
        ),
      };
      return acc;
    }, {})
  );

  // Process each chat concurrently.
  await Promise.all(
    Object.entries(data).map(async ([chatId, chatInfo]) => {
      // Build a map of existing message IDs.
      const messageIds = chatInfo.messages.reduce((acc, { id }) => {
        acc[id] = true;
        return acc;
      }, {});

      // Attempt to join the chat and fetch new messages.
      let joinRes = await client.get("join", {
        chatId,
        author: chatInfo.author,
        passwordHash: basicHash(basicHash(chatInfo.password)),
        messageIds,
      });

      if (joinRes) {
        setData((old) => {
          let messages = old[chatId].messages;

          if (joinRes?.[joinRes?.length - 1]?.deleted) {
            const toDelete = {};
            for (const msg of joinRes[joinRes.length - 1].deletedMessages) {
              toDelete[msg.id] = true;
              messages = messages.filter((msg) => !toDelete[msg.id]);
            }
          }

          joinRes.splice(joinRes.length - 1, 1);

          return {
            ...old,
            [chatId]: {
              ...old[chatId],
              unread: joinRes.length,
              messages: [
                ...messages,
                ...joinRes.map(({ id, message }) => {
                  try {
                    // Use chatInfo.password for decryption.
                    return {
                      ...JSON.parse(decrypt(chatInfo.password, message)),
                      id,
                    };
                  } catch (error) {
                    return {
                      type: "error",
                      data: "an error occurred (wrong password) (ignorable error)",
                    };
                  }
                }),
              ],
            },
          };
        });
      }

      // const messages = await client.get("messages", { chatId });
      // console.log(messages);

      // setData((old) => ({
      //   ...old,
      //   [chatId]: {
      //     ...old[chatId],
      //     messages,
      //   },
      // }));

      // Fetch and add user data.
      const users = await client.get("users", chatId);

      if (users) {
        setData((old) => ({
          ...old,
          [chatId]: {
            ...old[chatId],
            messages: [
              ...old[chatId].messages,
              ...users.map((user) => ({
                type: "user-joined",
                data: user,
                author: user,
                id: randomBytes(4).toString(CryptoJS.enc.Base64),
              })),
            ],
          },
        }));
      }
    })
  );
}

